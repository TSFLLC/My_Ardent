RLS & Data Protection Demo (2-Minute Presenter Script)
üîπ Introduction (0:00 ‚Äì 0:20)

‚ÄúGood afternoon everyone.
This month, we focused on demonstrating how Row-Level Security and Data Protection Techniques can strengthen our overall data-governance framework.
Our goal was to document, build, and test a proof of concept that shows how we can protect sensitive data while maintaining usability and compliance.‚Äù

üîπ Row-Level Security (RLS) (0:20 ‚Äì 1:10)

‚ÄúRLS controls who can see what data directly at the SQL Server level.
It ensures privacy ‚Äî users only see rows that belong to their department or business unit ‚Äî and it helps us meet compliance and audit requirements without adding complexity in the application layer.

In our proof of concept, we used a centralized mapping table that links users to their departments, and a security predicate function that filters records automatically based on session context.
This means HR users only see HR data, Finance sees Finance data, and so on.
It provides centralized, consistent, and auditable access control across all reporting and analytics tools.‚Äù

üîπ Data Protection Techniques (1:10 ‚Äì 1:50)

‚ÄúWe also evaluated four key data-protection techniques:

Dynamic Masking: hides data on-the-fly at query time ‚Äî great for production where we want to restrict what users see without altering the underlying data.

Static Masking: permanently masks data in a copy ‚Äî ideal for development or testing environments.

Tokenization: replaces sensitive identifiers with secure tokens stored in a vault ‚Äî used mainly for payment or ID systems.

Pseudonymization: replaces identifiers with fake but realistic values ‚Äî very effective for analytics and GDPR use cases.‚Äù

üîπ Wrap-Up (1:50 ‚Äì 2:00)

‚ÄúTogether, RLS and these data-protection techniques form a layered security model ‚Äî controlling both who can access and how data is revealed.
Our proof of concept validated these methods as practical, scalable, and compliant solutions for future production rollout.‚Äù


SELECT TOP (100) event_time, server_principal_name, action_id, schema_name, object_name, statement
FROM sys.fn_get_audit_file('F:\SqlAudit\TERA\*.sqlaudit', DEFAULT, DEFAULT)
WHERE action_id IN ('IN','UP','DL', 'EX','GP','RP')
ORDER BY event_time DESC;

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-- Audit:
SELECT TOP (20) event_time, server_principal_name, action_id, object_name, statement
FROM sys.fn_get_audit_file('F:\SqlAudit\TERA\*.sqlaudit', DEFAULT, DEFAULT)
WHERE action_id = 'EX'   -- EXECUTE
ORDER BY event_time DESC;



-- Run as admin:
GRANT SELECT ON OBJECT::Person.Address TO role_reporter;
REVOKE SELECT ON OBJECT::Person.Address FROM role_reporter;

-- Audit:
SELECT TOP (20) event_time, server_principal_name, action_id, statement
FROM sys.fn_get_audit_file('F:\SqlAudit\TERA\*.sqlaudit', DEFAULT, DEFAULT)
WHERE action_id IN ('GP','RP')   -- GRANT/REVOKE permission
ORDER BY event_time DESC;


Use master
SELECT name, is_state_enabled = CASE status WHEN 1 THEN 1 ELSE 0 END
FROM sys.server_audits WHERE name = 'Audit_TERA_File';

SELECT name, is_state_enabled 
FROM sys.database_audit_specifications 
WHERE name = 'DAS_TERA_Core' AND is_state_enabled = 1;


CREATE TABLE Sandbox.AuditProof(Id int);
ALTER TABLE Sandbox.AuditProof ADD CreatedAt datetime2 DEFAULT sysdatetime();
DROP TABLE Sandbox.AuditProof;




SELECT TOP (100) event_time, server_principal_name, action_id, object_name, statement
FROM sys.fn_get_audit_file('F:\SqlAudit\TERA\*.sqlaudit', DEFAULT, DEFAULT) 
WHERE action_id  Not IN ('SL') ORDER BY event_time DESC;



----------------------------------------------------------------
CREATE DATABASE AUDIT SPECIFICATION [DAS_TERA_Core]
FOR SERVER AUDIT [Audit_TERA_File]
/* Only log reads in these schemas */
ADD (SELECT ON SCHEMA::Person         BY PUBLIC),
ADD (SELECT ON SCHEMA::Sales          BY PUBLIC),
ADD (SELECT ON SCHEMA::Production     BY PUBLIC),
ADD (SELECT ON SCHEMA::Purchasing     BY PUBLIC),
ADD (SELECT ON SCHEMA::HumanResources BY PUBLIC),
/* Keep DML + changes as before (DB-wide or per-schema as you prefer) */
ADD (INSERT ON DATABASE::AdventureWorks2017 BY PUBLIC),
ADD (UPDATE ON DATABASE::AdventureWorks2017 BY PUBLIC),
ADD (DELETE ON DATABASE::AdventureWorks2017 BY PUBLIC),
ADD (EXECUTE ON DATABASE::AdventureWorks2017 BY PUBLIC),
ADD (DATABASE_OBJECT_CHANGE_GROUP),
ADD (DATABASE_PERMISSION_CHANGE_GROUP),
ADD (SCHEMA_OBJECT_CHANGE_GROUP),
ADD (SCHEMA_OBJECT_OWNERSHIP_CHANGE_GROUP)
WITH (STATE = ON);
GO

